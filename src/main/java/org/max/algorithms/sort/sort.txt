name		avgTime		space	stable
selection	O(n^2)		O(1)	0
bubble		O(n^2)		O(1)	1
insertion	O(n^2)		O(1)	1
quick		O(nlogn)	O(logn)	0
merge		O(nlogn)	O(n)	1
heap		O(nlogn)	O(1)	0
counting	O(n)		O(m)	1
radix		O(n)		O(n)	1

总结
1 不基于比较的排序，对样本数据有严格要求，不易改写
2 基于比较的排序，只要规定好两个样本怎么比较大小就可以直接复用
3 基于比较的排序，时间复杂度的极限是O(nlogn)
4 时间复杂度O(nlogn)，额外空间复杂度低于O(n),且稳定的基于比较的排序是不存在的
5 为了绝对的速度选快排，为了省空间选堆排，为了稳定性选归并

坑
1 归并的额外空间可以变成O(1),“归并排序 内部缓存发”，但是将变得不稳定（不如用堆）
2 “原地归并排序”，会让时间复杂度变成O(n^2) （不如插排）
3 快速排序可以变成稳定的，“01 stable sort”，但是对样本数据要求更多（不如桶排序）

Java里Array.sort()的优化：
1 先用反射确定是基础类型还时引用类型，如果是基础类型直接用快排。如果是引用类型，用归并排序。（考虑到稳定性）
2 在剩余元素不多的情况下从快排转为插入排序，因为快排常数项比较大。